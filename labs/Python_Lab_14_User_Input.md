## Lab 14 - Gathering user input and Deploying Configurations to Network Devices

In the previous lab, you created a modular python script that connects to a remote device and deploys interface configuration that was generated by reading in a YAML file. The login information, device type and the YAML file name were hard-coded within the script. This meant, potentially re-writing the code every time one of these parameters changed.

In this lab, you will still deploy the generated configuration to an end device, but will now collect user input for the parameters that were hard-coded earlier.

### Task 1 - Collecting input using Python's raw_input method

##### Step 1

Navigate to the `scripts` directory within your home directory.:

```
ntc@ntc:~$ cd scripts
ntc@ntc:~/scripts$
```

##### Step 2

We can start off by making a copy the file you created in the previous lab.

```
ntc@ntc:~/scripts$ cp deploy_csr1_config.py raw_user_input.py
ntc@ntc:~/scripts$
```

##### Step 3

Open this new file in Sublime Text or any other text editor.

The functions that we already created in the previous lab will be reused again. The new function needed to collect user input will use python's built-in `raw_input` function.


> Note: The `raw_input` function is replaced with `input` in Python 3


Go ahead and add this new function, calling it `user_input_interactive`

``` python

def user_input_interactive():
    """Collect the device details from the user interactively"""
    host = raw_input("Please enter the hostname or IP: ")
    device_type = raw_input("Please enter the device type: ")
    username = raw_input("Please enter the username: ")
    password = raw_input("Please enter the password: ")

    # create dictionary of interactive inputs that will be used for netmiko
    device_details = dict(device_type=device_type, ip=host,
                          username=username, password=password)
    return device_details

```


> Note: `raw_input` allows you to prompt for user input by displaying the string passed to it.

This function will collect the FQDN/IP address of the device, the device type and login credentials from the user, through an interactive prompt. 

##### Step 4

Call this new function from `main()`. The `device_details` dictionary will be used to store the login details and the device type needed by `netmiko` to connect to `csr1`. The values are provided by calling the function we just defined.

The following changes are required for the `main()` function:

You'll be adding the line:

```python
device_details = user_input_interactive()
```

and removing the following lines:

```python
device_type = 'cisco_ios'
ip = 'csr1'
username = 'ntc'
password = 'ntc123'
```


``` python
def main():
    """Generate and write interface configurations to a file
    """
    # Collect device details from user
    # Add the following line:
    device_details = user_input_interactive()

    interfaces_dict = get_interfaces()
    # Call a function that returns the configuration
    commands_list = get_commands_list(interfaces_dict)

    # Call a function that writes configs to a file
    config_file_name = '/tmp/device.cfg'
    generate_config_file(commands_list, config_file_name)

    # Deploy the configurations
    deploy_config(config_file_name, device_details)

    # End

```

    
##### Step 5

The final, complete script should look like below:

``` python
#!/usr/bin/env python
""" Code for Lab 13, Task 1"""
import yaml
from netmiko import ConnectHandler


def generate_commands(config_params):
    """Generate specific feature commands using feature name & value."""
    cmd_list = []
    for feature, value in config_params.items():
        command = " {} {}".format(feature, value)
        cmd_list.append(command)
    return cmd_list


def get_commands_list(interfaces):
    """Return a list of interface configuration commands."""
    # Iterate over the dictionary and generate configuration.

    commands_list = []
    for interface, config_params in interfaces.items():
        interface_command = "interface {}".format(interface)
        commands_list.append(interface_command)
        feature_commands = generate_commands(config_params)
        commands_list.extend(feature_commands)

    return commands_list


def print_config(commands_list):
    """Print the commands as a list and config."""
    # Print the results as a list
    print("Commands as a List:")
    print(commands_list)
    print("--------------------")
    # Print the results as config
    print("Commands Simulating Config File:")
    for command in commands_list:
        print(command)


def generate_config_file(commands_list, config_file_name):
    """Write interface configs to a file"""
    print("Opening file {} to write...".format(config_file_name))

    with open(config_file_name, "w") as file_handler:
        for command in commands_list:
            file_handler.write("{}\n".format(command))
    # Output the file details
    print("File {} has been generated...".format(config_file_name))


def get_interfaces_from_file():
    """Read in YAML data of the interfaces and generate the dictionary"""
    with open('csr1.yml') as yaml_file_handler:
        interfaces = yaml.load(yaml_file_handler)
    return interfaces


def get_interfaces():
    """ Return a dictionary of interfaces containing attributes"""
    interfaces = {
        "GigabitEthernet1": {
            "duplex": "full",
            "speed": 1000,
            "description": "Configured_by_Python_GigabitEthernet1"
        },
        "GigabitEthernet2": {
            "duplex": "half",
            "speed": 100,
            "description": "Configured_by_Python_GigabitEthernet2"
        },
        "Loopback101": {
            "description": "Configured_by_Python_Looback101"
        },
        "Loopback100": {
            "description": "Configured_by_Python_Loopback100"
        }
    }

    return interfaces


def deploy_config(config_file_name, device_details):
    """Connects to the device and deploys the configuration"""

    print("Connecting to the remote device {}...\n".format(device_details['ip']))
    # Invoke netmiko ConnectHandler and pass it the device details
    device = ConnectHandler(**device_details)
    # Send the config file
    print("Sending the configuration from file {}...".format(config_file_name))
    device.send_config_from_file(config_file=config_file_name)
    print("Changes sent to device. Please log in and verify...")


def user_input_interactive():
    """Collect the device details from the user interactively"""
    host = raw_input("Please enter the hostname or IP: ")
    device_type = raw_input("Please enter the device type: ")
    username = raw_input("Please enter the username: ")
    password = raw_input("Please enter the password: ")
    device_details = dict(device_type=device_type, ip=host,
                          username=username, password=password)
    return device_details


def main():
    """Generate and write interface configurations to a file
    """
    # Collect device details from user
    # Add the following line:
    device_details = user_input_interactive()

    interfaces_dict = get_interfaces()
    # Call a function that returns the configuration
    commands_list = get_commands_list(interfaces_dict)

    # Call a function that writes configs to a file
    config_file_name = '/tmp/device.cfg'
    generate_config_file(commands_list, config_file_name)

    # Deploy the configurations
    deploy_config(config_file_name, device_details)

    # End
if __name__ == "__main__":
    main()

```


##### Step 6

Save and execute this script:


``` shell
ntc@ntc:~/scripts$ python raw_user_input.py
Please enter the hostname or IP: csr1
Please enter the device type: cisco_ios
Please enter the username: ntc
Please enter the password: ntc123
Opening file /tmp/device.cfg to write...
File /tmp/device.cfg has been generated...
Connecting to the remote device csr1...

Sending the configuration from file /tmp/device.cfg...
Changes sent to device. Please log in and verify...

```

> Note: you can use the Python library called `getpass` to enter _hidden_ passwords.

##### Step 7

Finally, log into device `csr1` and ensure that the changes were pushed to the device.

``` shell
csr1#show interfaces description 
Interface                      Status         Protocol Description
Gi1                            up             up       Configured_by_Python_GigabitEthernet1
Gi2                            admin down     down     Configured_by_Python_GigabitEthernet2
Gi3                            admin down     down     
Gi4                            admin down     down     
Lo100                          up             up       Configured_by_Python_Loopback100
Lo101                          up             up       Configured_by_Python_Loopback101
csr1#
```

You have now successfully created a modular python script that reads in configration data from a YAML encoded file, generates device interface configurations and deploys the configurations to the end device!

### Task 2 - Collecting Input Using argparse

Prompting the user is one way to collect input interactively. In this task we will use the Python `argparse` module to collect input from the user, in a style that mimics most Unix commands.

Our goal here is to allow the script to help instruct the user on the usage/limitations and understand how to supply default values that users can potentially override.

##### Step 1

Navigate to the `scripts` directory within your home directory.:

```
ntc@ntc:~$ cd scripts
ntc@ntc:~/scripts$
```

##### Step 2

We can start off by making a copy the file you created in the previous lab.

```
ntc@ntc:~/scripts$ cp raw_user_input.py flags_user_input.py
ntc@ntc:~/scripts$
```

##### Step 3

Open this new file in Sublime Text or any other text editor.

The functions that we already created in the previous lab can be reused. The new function needed to collect user input will use python's `argparse` library. Go ahead and import this at the top of your script.

``` python
import argparse

```

Go ahead and add this new function, calling it `user_input_parse`

``` python
def user_input_parse():
    """Collect the device details using an unix-command-like menu"""
    parser = argparse.ArgumentParser(description='Collect device and data'
                                     ' file information to configure a device')
    parser.add_argument('-i', '--ip',
                        help='Enter the IP address or hostname of the device',
                        required=True)
    parser.add_argument('-d', '--device_type', help='Enter the device type',
                        required=True)
    parser.add_argument('-u', '--username', help='Enter the username',
                        required=True)
    parser.add_argument('-p', '--password', help='Enter the password',
                        required=True)

    # parse all args and render 
    input_data = parser.parse_args()

    host = input_data.ip
    username = input_data.username
    password = input_data.password
    device_type = input_data.device_type

    user_input = dict(device_type=device_type, ip=host,
                      username=username, password=password)
    return user_input


```


This function will collect the FQDN/IP address of the device, the device type, login credentials and the configuration data YAML file through Unix-style flags. The function then returns a dictionary object that contains the user input.

##### Step 4

Call this new function from `main()`. Collect the user input dictionary into a variable called `user_input`. 

Ensure you remove the following lines from the `main()` function:

```python
device_details = user_input_interactive()` 

```

Add the following lines to the function:

```python
user_input = user_input_parse()
device_details = user_input  # not technically reuiqred, but we're doing this to limit changes in the function call to `deploy_config()`
```

Here is the updated `main()` function.

``` python
def main():
    """Generate and write interface configurations to a file
    """

    # Collect input from user
    user_input = user_input_parse()


    # Collect the device_details
    device_details = user_input

    # Collect the interface details from file
    interfaces_dict = get_interfaces()
    # Call a function that returns the configuration
    commands_list = get_commands_list(interfaces_dict)

    # Call a function that writes configs to a file
    config_file_name = '/tmp/device.cfg'
    # Call a function that writes configs to a file
    generate_config_file(commands_list, config_file_name)

    # Deploy the configurations
    deploy_config(config_file_name, device_details)

    # End

```


##### Step 5

The final complete script should look as follows:

``` python
#!/usr/bin/env python
""" Code for Lab 15, Task 2"""
import yaml
from netmiko import ConnectHandler
import argparse

def generate_commands(config_params):
    """Generate specific feature commands using feature name & value."""
    cmd_list = []
    for feature, value in config_params.items():
        command = " {} {}".format(feature, value)
        cmd_list.append(command)
    return cmd_list


def get_commands_list(interfaces):
    """Return a list of interface configuration commands."""
    # Iterate over the dictionary and generate configuration.

    commands_list = []
    for interface, config_params in interfaces.items():
        interface_command = "interface {}".format(interface)
        commands_list.append(interface_command)
        feature_commands = generate_commands(config_params)
        commands_list.extend(feature_commands)

    return commands_list


def print_config(commands_list):
    """Print the commands as a list and config."""
    # Print the results as a list
    print("Commands as a List:")
    print(commands_list)
    print("--------------------")
    # Print the results as config
    print("Commands Simulating Config File:")
    for command in commands_list:
        print(command)


def generate_config_file(commands_list, config_file_name):
    """Write interface configs to a file"""
    print("Opening file {} to write...".format(config_file_name))

    with open(config_file_name, "w") as file_handler:
        for command in commands_list:
            file_handler.write("{}\n".format(command))
    # Output the file details
    print("File {} has been generated...".format(config_file_name))


def get_interfaces_from_file(file_name):
    """Read in YAML data of the interfaces and generate the dictionary"""
    with open(file_name) as yaml_file_handler:
        interfaces = yaml.load(yaml_file_handler)
    return interfaces


def get_interfaces():
    """ Return a dictionary of interfaces containing attributes"""
    interfaces = {
        "GigabitEthernet1": {
            "duplex": "full",
            "speed": 1000,
            "description": "Configured_by_Python_GigabitEthernet1"
        },
        "GigabitEthernet2": {
            "duplex": "half",
            "speed": 100,
            "description": "Configured_by_Python_GigabitEthernet2"
        },
        "Loopback101": {
            "description": "Configured_by_Python_Looback101"
        },
        "Loopback100": {
            "description": "Configured_by_Python_Loopback100"
        }
    }

    return interfaces


def deploy_config(config_file_name, device_details):
    """Connects to the device and deploys the configuration"""

    print("Connecting to the remote device {}...\n".format(device_details['ip']))
    # Invoke netmiko ConnectHandler and pass it the device details
    device = ConnectHandler(**device_details)
    # Send the config file
    print("Sending the configuration from file {}...".format(config_file_name))
    device.send_config_from_file(config_file=config_file_name)
    print("Changes sent to device. Please log in and verify...")


def user_input_interactive():
    """Collect the device details from the user interactively"""
    host = raw_input("Please enter the hostname or IP: ")
    device_type = raw_input("Please enter the device type: ")
    username = raw_input("Please enter the username: ")
    password = raw_input("Please enter the password: ")
    device_details = dict(device_type=device_type, ip=host,
                          username=username, password=password)
    return device_details

def user_input_parse():
    """Collect the device details using an unix-command-like menu"""
    parser = argparse.ArgumentParser(description='Collect device and data'
                                     ' file information to configure a device')
    parser.add_argument('-i', '--ip',
                        help='Enter the IP address or hostname of the device',
                        required=True)
    parser.add_argument('-d', '--device_type', help='Enter the device type',
                        required=True)
    parser.add_argument('-u', '--username', help='Enter the username',
                        required=True)
    parser.add_argument('-p', '--password', help='Enter the password',
                        required=True)

    input_data = parser.parse_args()
    host = input_data.ip
    username = input_data.username
    password = input_data.password
    device_type = input_data.device_type

    user_input = dict(device_type=device_type, ip=host,
                      username=username, password=password)
    return user_input


def main():
    """Generate and write interface configurations to a file
    """

    # Collect input from user
    user_input = user_input_parse()

    # Collect the device_details
    device_details = user_input

    # Collect the interface details from file
    interfaces_dict = get_interfaces()
    # Call a function that returns the configuration
    commands_list = get_commands_list(interfaces_dict)

    # Call a function that writes configs to a file
    config_file_name = '/tmp/device.cfg'
    # Call a function that writes configs to a file
    generate_config_file(commands_list, config_file_name)

    # Deploy the configurations
    deploy_config(config_file_name, device_details)

    # End


if __name__ == "__main__":
    main()

```

##### Step 6

Save and execute this script, first without any arguments


``` shell
ntc@ntc:~/scripts$ python flags_user_input.py
usage: flags_user_input.py [-h]  -i IP -d DEVICE_TYPE -u
                             USERNAME -p PASSWORD
flags_user_input.py: error: argument -i/--ip is required

```


> Note the usage instructions and required flags

##### Step 7

Next try and execute the script with the `-h` or `--help` flag:

``` shell
ntc@ntc:~/scripts$ python flags_user_input.py --help
usage: flags_user_input.py [-h] -i IP -d DEVICE_TYPE -u
                             USERNAME -p PASSWORD
Collect device and data file information to configure a device

optional arguments:
  -h, --help            show this help message and exit
  -i IP, --ip IP        Enter the IP address or hostname of the device
  -d DEVICE_TYPE, --device_type DEVICE_TYPE
                        Enter the device type
  -u USERNAME, --username USERNAME
                        Enter the username
  -p PASSWORD, --password PASSWORD
                        Enter the password

```

##### Step 8

Finally, execute the script with all the required inputs.


``` shell
ntc@ntc:~/scripts$ python flags_user_input.py -i csr1 -d cisco_ios -u ntc -p ntc123                             
Opening file /tmp/device.cfg to write...
File /tmp/device.cfg has been generated...
Connecting to the remote device csr1...

Sending the configuration from file /tmp/device.cfg...
Changes sent to device. Please log in and verify...

```

In this lab you have successfully used 2 ways to create a modular python script to collect user input. Using the user input, the script then generated the desired interface configurations. Finally, based on the device, username and password supplied by the user, our script deployed configuration to the end device.

### Task 3 - Using sys.argv

This task shows the quickest way to get started working with command line arguments.  While `argparse` is recommended for more user-friendly scripts, you may want to use `sys.argv` for a quick and easy to pass in args into a script. 

This task shows how to get started with `sys.argv`

##### Step 1

Create a new script called `basic_args.py` in the `scripts` directory.

##### Step 2

In the script, `import sys`.  

Add a print statement that says "HERE ARE MY ARGUMENTS: "

Right under the print statement, add the following line:

```python
print sys.argv

```

It'll look like this:

```python
#! /usr/bin/env python

import sys

if __name__ == "__main__":

    print 'HERE ARE MY ARGUMENTS: '
    print sys.argv

```

##### Step 3

Save and execute the script.

```
ntc@ntc:~/scripts$ python basic_args.py
HERE ARE MY ARGUMENTS:
['my_args.py']
```

Can you tell that a list was printed out?  This is a list with one element.  We can see that the first and only element in the list is the name of the Python file being executed.

##### Step 4

Re-run the script like so:

```
ntc@ntc:~/scripts$ python basic_args.py cisco arista juniper
```

After running this script, you will see the following output:

```
HERE ARE MY ARGUMENTS:
['basic_args.py', 'cisco', 'arista', 'juniper']
```

Again, notice that the script name is always element 0 and then every other argument is another element in the list.

##### Step 5

Only print out the first *real* argument, i.e. "cisco".

Additionally, save `sys.argv` as `args`.  This will simplfy working with the objects going forward.

```python
if __name__ == "__main__":

    print 'HERE ARE MY ARGUMENTS: '

    args = sys.argv

    print args[1]
```

Run the script again.

```
ntc@ntc:~/scripts$ python basic_args.py cisco arista juniper
```

```
HERE ARE MY ARGUMENTS:
cisco
```

As you can see, using the `sys` module with the `argv` variable, it is quite fast and easy to pass in arguments from the command line.

One other trick is to use indexing with lists to only ever print everything BUT the first element.  

> You can use `[1:]` to access the list starting at index 1.  You can also do `[1:<ending index #>` too.
> 

Take a look:

```python
>>> args = ['basic_args.py', 'cisco', 'arista', 'juniper']
>>> 
>>> args[1:]
['cisco', 'arista', 'juniper']
>>> 
>>> 
>>> limited = args[1:]
>>> 
>>> if limited:
...   'args were passed in'
... 
'args were passed in'
>>> 
>>> 
>>> args = ['basic_args.py']
>>> 
>>> limited = args[1:]
>>> 
>>> if limited:
...   'args were passed in'
... 
>>> 
```

